<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'/>
    <title>Rapid Tree Note</title>
    <link rel="icon" href="/RTN/Resources/favicon.ico" type="image/x-icon">
    
    
  </head>
  <body style="background-color: rgb(44, 46, 54); font-family: monospace;">
    <div style="display: flex; align-items: center; justify-content: center; height: 10vh; width: 100%;">
        <div style="width: 50%; display: flex; align-items: center; justify-content: left;">
          <h1 style="color: whitesmoke; font-size: 4vw;">Rapid Tree Notetaker</h1>
        </div>
        <div style="width: 10%; height: 100%; display: flex; align-items: center;; justify-content: center;">
          <button onclick="navigateProgram()" style="width: 95%; height: 75%; background-color: rgba(67, 72, 91, 1.0); outline: solid 2px black; box-shadow: none; color: whitesmoke; font-size: 1.5vw;">Program</button>
        </div>
        <div style="width: 10%; height: 100%; display: flex; align-items: center; justify-content: center;">
          <button onclick="navigateInspiration()" style="width: 95%; height: 75%; background-color: rgba(67, 72, 91, 1.0); outline: solid 2px black; box-shadow: none; color: whitesmoke; font-size: 1.5vw;">Inspiration</button>
        </div>
        <div style="width: 10%; height: 100%; display: flex; align-items: center; justify-content: center;">
          <button onclick="navigateHistory()" style="width: 95%; height: 75%; background-color: rgba(67, 72, 91, 1.0); outline: solid 2px black; box-shadow: none; color: whitesmoke; font-size: 1.5vw;">History</button>
        </div>
        <div style="width: 10%; height: 100%; display: flex; align-items: center; justify-content: center;">
          <button onclick="navigateCredits()" style="width: 95%; height: 75%; background-color: rgba(67, 72, 91, 1.0); outline: solid 2px black; box-shadow: none; color: whitesmoke; font-size: 1.5vw;">Credits</button>
        </div> 
        <div style="width: 10%; display: flex; align-items: center; justify-content: center;">
          <img src="./Resources/RTN_Logo-Light.svg" alt="RTN Website Logo" style="width: 5vw;"></img>
        </div>
    </div>
    
    <div style="display: flex; justify-content: center; align-items: flex-start; height: 80vh;">
      <pre style="color: whitesmoke; font-size: 0.8vw;">
History
├────── Discovery
│       ├────── In the summer of 2023, I (Brendan Rood), discovered <a style="color:cyan" href="https://tree.nathanfriend.io">https://tree.nathanfriend.io</a> and immediately fell in love with it.
│       ├────── The neat little tree diagrams were exactly how I like to take notes on paper, and I quickly found that I could retain information better when my notes were in this format.
│       └────── Immediately, however, I began to run into problems. 
│               ├────── Resumability
│               │       ├────── My Boss (<a style="color:cyan" href="https://www.d.umn.edu/~pahp">Peter Peterson Ph.D.</a>) in the <a style="color:cyan" href="https://lars.d.umn.edu">LARSLab</a> was happy to work with whatever format of notes made me happy.
│               │       ├────── However, it was nearly impossible for him to edit the documents I produced with <a style="color:cyan" href="https://tree.nathanfriend.io">https://tree.nathanfriend.io</a>.
│               │       └────── This led to the unfortunate junction where I had to decide between notes formatted in a way that worked for me vs. notes formated in a way that worked for others.
│               └────── Computation Time
│                       ├────── <a style="color:cyan" href="https://tree.nathanfriend.io">https://tree.nathanfriend.io</a> is a great tool but it slows down exponentially with longer documents.
│                       ├────── Given the length of documents I was writing, I would often reach the point where I had to wait 2-4 seconds between every keypress.
│                       └────── This was less than ideal, and I knew a more optimized solution must be possible.
├────── Planning
│       ├────── Thankfully, with the JavaScript and HTML knowledge I had gained working on the <a style="color:cyan" href="https://lars.d.umn.edu">LARSLab</a>'s Security Misconceptions Game, I felt like I could potentially author my own fixes.
│       ├────── I went through many iterations of the program before I landed on the final version, with dual-panels, buffer shuffling, and a ton of Regular Expressions.
│       └────── I want to share my algorithm and final implementation so that others can learn from my work without having to reinvent the wheel as I did.
│               └────── <a style="color:cyan" href="https://tree.nathanfriend.io">https://tree.nathanfriend.io</a>'s code is publically available, <a style="color:cyan" href="https://github.umn.edu/UMDLARS/Rapid-Tree-Note">just as this project's code is</a>, but is not very well documented.
├────── The Program
│       ├────── Defining The Glyphs
│       │       ├────── A standard set of glyphs was to be used in order to generate the trees and perform Regular Expressions on them.
│       │       ├────── Each glyph is exactly 8 monospaced characters long, as that is the width of a tab in this implementation.
│       │       └────── List of Glyphs
│       │               ├────── Bend ---------- "└────── "
│       │               ├────── Fork ---------- "├────── "
│       │               ├────── Line / Pipe --- "│       "
│       │               └────── Gap ----------- "        "
│       ├────── Understanding the Webpage
│       │       ├────── Creating a single-panel version of the application was significantly harder than creating a dual-panel version.
│       │       │       ├────── Doing so required keeping two versions of the contents, one with tabs and one with glyphs, and constantly switching back and forth between them.
│       │       │       ├────── This resulted in an insufferable amount of math to keep adjusting the cursor to be intuitive.
│       │       │       └────── It also significantly increased computation time.
│       │       └────── My Solution - Just stack it!
│       │               ├────── On 9/18/23, I realized that, if the size of the glyphs were exactly the same size of the tabs, I could just stack my dual-panel approach!
│       │               ├────── This website accomplishes the illusion of edit-in-place by using the CSS "z-index" attribute to stack the RAW textarea on top of the EXE textarea.
│       │               ├────── The RAW textarea made see-through by setting the CSS "background-color" attribute to an RGBA value where A = 0 (totally transparent).
│       │               ├────── The EXE textarea is made inaccessible to the user by using the CSS "pointer-events: none" attribute.
│       │               ├────── Whenever the tree needs to be redrawn, it pulls data from RAW, parses it, and writes it to EXE.
│       │               ├────── Because tabs are transparent, this allows only the glyphs to be seen through the top textarea.
│       │               │       └────── This technically means that there is a duplicate version of the text underneath the text, the user just can't see it.
│       │               └────── IMPORTANT: Copy Handling
│       │                       ├────── Because the user can only access the top textarea, it is important to intercept and replace the result of a COPY request.
│       │                       ├────── This is accomplished by taking the START and END points of the selection in RAW and doing the following:
│       │                       │       ├────── Count the number of tabs that occur before START in the string and multiply it by 7 (we replace "\t" with len(8) so we increase by 7).
│       │                       │       │       └────── This is now EXE_START
│       │                       │       └────── Count the number of tabs that occur before START in the string * 7 and then add the number of tabs between START and END * 7 (widen it)
│       │                       │               └────── This is now EXE_END
│       │                       └────── Take EXE_START and EXE_END and pull the value off that textarea from those indexes and write that to the clipboard instead.
│       ├────── The Algorithm
│       │       ├────── I seriously recommend any aspiring developers take a look firsthand at /main.js > class ProcessingTree > totalParse()
│       │       └────── I will attempt to explain the algorithm in English below
│       │               ├────── 1 - Take the input string and break it into lines. Produce node objects where level = the number of leading tabs and data = all content except the tabs.
│       │               ├────── 2 - Iterate over all nodes and produce treeblocks (see /treeblocks.js).
│       │               │       ├────── Produce N "NEW" treeblocks where N = node.level
│       │               │       ├────── Then, read node.data. If node.data == "", create a END block. If node.data != "", create a DATA block.
│       │               │       │       └────── The distinction between END and DATA is to make drawing new lines of the tree neater.
│       │               │       └────── We will end up producing an array of arrays, where the content of that sub-array is N "NEW" blocks followed by a "DATA" or "END" block.
│       │               ├────── 3 - Converting NEW blocks to [BEND, FORK, GAP, LINE]
│       │               │       ├────── We then iterate over all tree blocks in order (take the array, open a subarray, solve each block of the subarray in order, then open the next subarray).
│       │               │       ├────── Checking for BEND
│       │               │       │       ├────── We must evaluate this case first, as other definitions rely on it and it is a more specific case of FORK.
│       │               │       │       ├────── If the block to the right is not DATA, we stop checking and conclude it should not BEND.
│       │               │       │       ├────── Then, If the block below is null (EOF), we stop checking and conclude it should BEND.
│       │               │       │       ├────── Then, we search below the block in question until DATA or EOF is encountered, and save that distance.
│       │               │       │       ├────── Then, we search below the block one to the right of the block in question until DATA or EOF is encountered, and save that distance.
│       │               │       │       └────── If the distance to down is less than or equal to the distance right, solution = bend. If not, solution remains "".
│       │               │       ├────── Checking for FORK
│       │               │       │       └────── If we have not already found the solution and the block to the right is DATA, solution = FORK.
│       │               │       ├────── Checking for GAP
│       │               │       │       └────── If we have not already found the solution and the block above is BEND or GAP, solution = GAP.
│       │               │       ├────── Checking for LINE / PIPE
│       │               │       │       └────── If we have not already found the solution and the block above is FORK or LINE, solution = LINE.
│       │               │       └────── Each time we find the solution, we replace the NEW treeblock with the corresponding type.
│       │               └────── 4 - Printing the Output
│       │                       ├────── Each treeblock includes its glyph in its .data field.
│       │                       ├────── For example, GAP.value = 8 spaces
│       │                       ├────── Each DATA block was already initialized such that DATA.data = node.data.
│       │                       ├────── Therefore, we simply iterate over the entire array schema and concatenate BLOCK.data to the output buffer.
│       │                       └────── This buffer can then replace the contents of EXE and everything works!
│       └────── Resuming Documents, Misc Error Handling, and Illegal Actions
│               ├────── Certain actions the user can take may result in an illegal tree.
│               ├────── Although not perfect, I have implemented certain checks to ensure that it is far more difficult to accidentally create an illegal tree.
│               ├────── Key Interceptions
│               │       ├────── Illegal trees can be prevented by intercepting TAB and ENTER keypresses and making sure their result would be possible to parse.
│               │       ├────── To any aspiring developers take a look firsthand at /main.js > class VirtualBuffer > keyHandler() > function shouldTab() and function shouldNewLine()
│               │       └────── These functions make sure that the current, previous, and next line meet certain conditions, and if those conditions are met, the key is allowed to process.
│               └────── Regular Expression Validation
│                       ├────── The primary function of Regular Expressions in this application is to recognize glyph characters and convert them back into tab characters.
│                       │       └────── this.ref.value = this.ref.value.replace(/├────── |│       |└────── |        /gm, "\t");
│                       ├────── I also included a regular expression that can handle the length-4 outputs over <a style="color:cyan" href="https://tree.nathanfriend.io">https://tree.nathanfriend.io</a> and older versions of RTN.
│                       │       └────── this.ref.value = this.ref.value.replace(/├── |│   |└── |    /gm, "\t");
│                       └────── Finally, there is a crude regular expression to remove tab characters from anywhere but the start of a line.
│                               └────── this.ref.value = this.ref.value.replace(/(?:\t+[\S ]+)(\t+)/gm, "\t");
├────── Github Release
│       ├────── The full source code of this project is available on github at <a style="color:cyan" href="https://github.umn.edu/UMDLARS/Rapid-Tree-Note">https://github.umn.edu/UMDLARS/Rapid-Tree-Note</a>.
│       └────── It is free to use, modify, etc, I just ask that you credit me, "Brendan Rood", and provide a link to this original Application.
└────── Acknoledgements
                ├────── This project would not have been possible without contributions from the <a style="color:cyan" href="https://cahss.d.umn.edu/centers-facilities/viz-lab-mmad-lab">MMADLab</a>, <a style="color:cyan" href="https://lars.d.umn.edu">LARSLab</a>, <a style="color:cyan" href="https://www.d.umn.edu/~pahp">Peter Peterson Ph.D.</a>, and Ethan Schurman.
                └────── For more information please visit the <a style="color:cyan" href="https://lars.d.umn.edu/RTN/credits.html">credits page</a>.
      </pre>     
    </div>

  <script> // subpage navigation
    function navigateProgram()
    {
      location.href="https://lars.d.umn.edu/RTN/program.html";
    }
    function navigateInspiration()
    {
      location.href="https://lars.d.umn.edu/RTN/inspiration.html";
    }
    function navigateCredits()
    {
      location.href="https://lars.d.umn.edu/RTN/credits.html";
    }
    function navigateHistory()
    {
      location.href="https://lars.d.umn.edu/RTN/history.html";
    }
  </script>
  </body>
</html>